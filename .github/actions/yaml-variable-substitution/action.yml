name: 'Container App YAML Variable Substitution'
description: 'Process variable substitutions in Container App YAML files'
inputs:
  app_yaml_path:
    description: 'Path to the app.yaml file to process'
    required: true
  output_path:
    description: 'Path to write the processed app.yaml file'
    required: true
  environment:
    description: 'Target environment (dev, test, prod)'
    required: false
    default: 'dev'
  keyvault_name:
    description: 'Azure KeyVault name for kv: substitutions'
    required: false
    default: ''
  script_repo:
    description: 'Repository containing the script (default to the current action repo)'
    required: false
    default: 'HafslundEcoVannkraft/stratus-tf-res-app-containerapp'
  script_ref:
    description: 'Branch, tag or SHA to checkout'
    required: false
    default: 'main'

runs:
  using: "composite"
  steps:
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.10"

    - name: Install dependencies
      shell: bash
      run: |
        pip install azure-identity azure-keyvault-secrets

    - name: Azure login
      if: inputs.keyvault_name != ''
      uses: azure/login@v2
      with:
        client-id: ${{ env.AZURE_CLIENT_ID }}
        tenant-id: ${{ env.AZURE_TENANT_ID }}
        subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

    - name: Check if app.yaml exists
      id: check_file
      shell: bash
      run: |
        if [ -f "${{ inputs.app_yaml_path }}" ]; then
          echo "EXISTS=true" >> $GITHUB_OUTPUT
        else
          echo "EXISTS=false" >> $GITHUB_OUTPUT
          echo "WARNING: File ${{ inputs.app_yaml_path }} not found"
        fi

    - name: Check if app.yaml uses substitution syntax
      id: check_substitution
      if: steps.check_file.outputs.EXISTS == 'true'
      shell: bash
      run: |
        if grep -q '\${.*}' "${{ inputs.app_yaml_path }}"; then
          echo "USES_SUBSTITUTION=true" >> $GITHUB_OUTPUT
        else
          echo "USES_SUBSTITUTION=false" >> $GITHUB_OUTPUT
          # If no substitution, just copy the file to the output path
          mkdir -p "$(dirname "${{ inputs.output_path }}")"
          cp "${{ inputs.app_yaml_path }}" "${{ inputs.output_path }}"
        fi

    - name: Create substitution script
      if: steps.check_file.outputs.EXISTS == 'true' && steps.check_substitution.outputs.USES_SUBSTITUTION == 'true'
      shell: bash
      run: |
        cat > process_substitutions.py << 'EOF'
#!/usr/bin/env python3
"""
Variable Substitution Processor for Container App YAML Files

This script processes variable substitution patterns in YAML files used for
Container App deployments. It supports multiple sources for variables:
- GitHub Variables (vars:)
- GitHub Secrets (secrets:)
- Azure KeyVault (kv:)
- Environment Variables (env:)

Substitution syntax in YAML:
  ${vars:VARIABLE_NAME:default_value}   - Variable with default
  ${vars:VARIABLE_NAME!}                - Required variable
  ${secrets:SECRET_NAME}                - Secret
  ${kv:KEYVAULT_SECRET}                 - KeyVault secret
  ${env:ENV_VAR}                        - Environment variable
"""

import re
import os
import sys
import json
import argparse
from azure.keyvault.secrets import SecretClient
from azure.identity import DefaultAzureCredential

def process_yaml_substitutions(yaml_content, sources):
    """Process variable substitutions in a YAML string."""
    # Regex to match ${prefix:name:default} or ${prefix:name!}
    pattern = r'\${(vars|secrets|kv|env):([^:!}]+)(?::([^}]+)|!)?}'

    def replace_var(match):
        source_type = match.group(1)
        var_name = match.group(2)
        default_value = match.group(3)
        required = match.group(0).endswith('!}')

        if source_type not in sources:
            if required:
                raise ValueError(f"Source '{source_type}' not configured but required for '{var_name}'")
            return match.group(0)

        # Special handling for KeyVault source
        if source_type == 'kv' and hasattr(sources[source_type], 'get_secret'):
            try:
                # Fetch secret from KeyVault on demand
                value = sources[source_type].get_secret(var_name).value
            except Exception as e:
                if required:
                    raise ValueError(f"Failed to retrieve required KeyVault secret '{var_name}': {str(e)}")
                value = None
        else:
            value = sources[source_type].get(var_name)

        if value is None:
            if required:
                raise ValueError(f"Required variable '{var_name}' from source '{source_type}' is missing")
            return default_value if default_value is not None else match.group(0)

        return value

    return re.sub(pattern, replace_var, yaml_content)

def main():
    parser = argparse.ArgumentParser(description='Process YAML variable substitutions')
    parser.add_argument('--input', required=True, help='Input YAML file')
    parser.add_argument('--output', required=True, help='Output YAML file')
    parser.add_argument('--vars-source', choices=['github', 'env'], default='github', help='Source for vars:')
    parser.add_argument('--secrets-source', choices=['github', 'env'], default='github', help='Source for secrets:')
    parser.add_argument('--kv-source', choices=['azure-keyvault', 'none'], default='azure-keyvault', help='Source for kv:')
    parser.add_argument('--environment', help='GitHub environment name')
    parser.add_argument('--keyvault-name', help='Azure KeyVault name')
    args = parser.parse_args()

    sources = {}

    # Setup vars source
    if args.vars_source == 'github':
        # For GitHub, we rely on the runner having environment variables set
        # GitHub automatically sets env vars for variables associated with the environment
        vars_dict = {k[5:]: v for k, v in os.environ.items() if k.startswith('VARS_')}
        sources['vars'] = vars_dict
    elif args.vars_source == 'env':
        sources['vars'] = dict(os.environ)

    # Setup secrets source
    if args.secrets_source == 'github':
        # GitHub automatically sets env vars for secrets associated with the environment
        secrets_dict = {k[7:]: v for k, v in os.environ.items() if k.startswith('SECRETS_')}
        sources['secrets'] = secrets_dict
    elif args.secrets_source == 'env':
        # This is for local testing - not recommended for production
        sources['secrets'] = {k[7:]: v for k, v in os.environ.items() if k.startswith('SECRETS_')}

    # Setup KeyVault source
    if args.kv_source == 'azure-keyvault' and args.keyvault_name:
        credential = DefaultAzureCredential()
        keyvault_url = f"https://{args.keyvault_name}.vault.azure.net/"
        client = SecretClient(vault_url=keyvault_url, credential=credential)

        # We don't want to fetch all secrets at once
        # KeyVault values will be fetched on demand
        sources['kv'] = client

    # Always include environment variables as a source
    sources['env'] = dict(os.environ)

    # Read input file
    with open(args.input, 'r') as f:
        yaml_content = f.read()

    # Process substitutions
    try:
        processed_yaml = process_yaml_substitutions(yaml_content, sources)
    except ValueError as e:
        print(f"Error processing substitutions: {str(e)}", file=sys.stderr)
        sys.exit(1)

    # Write output file
    with open(args.output, 'w') as f:
        f.write(processed_yaml)

    print(f"Successfully processed '{args.input}' to '{args.output}'")

if __name__ == '__main__':
    main()
EOF

        chmod +x process_substitutions.py

    - name: Process app.yaml substitutions
      if: steps.check_file.outputs.EXISTS == 'true' && steps.check_substitution.outputs.USES_SUBSTITUTION == 'true'
      shell: bash
      run: |
        # Create the output directory if it doesn't exist
        mkdir -p "$(dirname "${{ inputs.output_path }}")"

        # Process substitutions
        python process_substitutions.py \
          --input "${{ inputs.app_yaml_path }}" \
          --output "${{ inputs.output_path }}" \
          --environment "${{ inputs.environment }}" \
          --keyvault-name "${{ inputs.keyvault_name }}"
